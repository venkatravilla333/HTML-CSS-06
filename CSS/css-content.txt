
                                         CSS CONTENT
                                         ===========


1. What is CSS
   ===========

CSS stands for Cascading Style Sheet. It is a styling language, by using CSS we can style the html content or elements on webpage by using CSS properties. CSS properties will be in key value pair. 


2. How many ways we can add css to html elements
   =============================================


   1) Inline 

   - By using style attribute we can apply css directly to that html element. By using inline style we can apply only css to only one element at a time.

   2) Internal

   - By using style tag in head tag we can apply css to many html elements in the same html file at a time html elements. 

   3) Extrenal

   - By using external style sheet we can apply css to many html elements in different html files at a time. We can link external css file to html file by using link tag in head tag.


   3. CSS selectors
   =============
 
  - CSS selectors are used to select the HTML elements you want to style.

  - We can divide CSS selectors into several categories:

   1. Simple selectors (select elements based on tag, id, class) (3 selectors)

   2. Combinator selectors (select elements based on a specific relationship between them)

      a) Descendent selector => div p {} - all childs
      b) Child selector      => div>p {} - direct childs    
      c) Adjacent sibling    => div+p {} - next one (sibling)
      d) General sibling     => div~p {} - next all siblings

   3. Pseudo-class selectors (select elements based on a certain state)

   4. Pseudo-elements selectors (select and style a part of an element)

   5. Attribute selectors (select elements based on an attribute or attribute value) (4 selectors)

   6. Universal Selector (The universal selector (*) selects all HTML elements on the page)

   7. Grouping Selector (To group selectors, separate each selector with a comma)

      Allows you to apply the same styles to multiple selectors.

      Example: h1, h2, h3 { font-family: Arial, sans-serif; }


1.Type (Element) Selector:
  -----------------------

Selects elements by their HTML tag name.

Example: p { color: blue; }

2.Class Selector:
  --------------

Selects elements by their class attribute.

Example: .my-class { font-weight: bold; }

3.ID Selector:
  -----------

Selects a single element by its unique ID attribute.

Example: #my-id { background-color: yellow; }

4.Universal Selector:
  ------------------

Selects all elements on the page.

Example: * { margin: 0; }

5.Descendant Selector (all childs):
  -------------------

Selects an element that is a descendant of another element.

Example: ul li { list-style: square; }

6.Child Selector (direct child):
  --------------

Selects an element that is a direct child of another element.

Example: ul > li { font-style: italic; }

7.Adjacent Sibling Selector (next sibling):
  -------------------------

Selects an element that is immediately preceded by another element.

Example: h2 + p { color: red; }

8.General Sibling Selector (next all siblings):
  ------------------------

Selects elements that are siblings of a specified element.

Example: h2 ~ p { font-size: 18px; }


9.Pseudo-Class Selector:
   ---------------------

Selects elements based on a specific state or interaction, such as :hover, :active, and :focus.

Example: a:hover { text-decoration: underline; }

10.Pseudo-Element Selector:
   -----------------------

Selects and styles a part of an element's content, such as  

=> ::first-letter ::first-line and ::before and ::after

Example: p::before { content: "Note: "; }

Pseudo-elements in CSS are used to style a specific part of an element. They are denoted by double colons (::) and are often used with the ::before and ::after pseudo-elements to insert content before or after an element. Here's an example of using the ::before pseudo-element to add content before an element:

.myclass::before {
  content: "This is content";
  font-weight: bold;
  color: red;
}

.myclass::after {
  content: "This is content";
  font-weight: bold;
  color: white;
}


11.Grouping Selector:
   -----------------

Allows you to apply the same styles to multiple selectors.

Example: h1, h2, h3 { font-family: Arial, sans-serif; }


12.Attribute Selector:
  ------------------

Selects elements based on the value of their attributes.

Example: input[type="text"] { border: 1px solid #ccc; }



13.Attribute Value Starts With Selector:
   ------------------------------------

Selects elements whose attribute values start with a specified string.

Example: [href^="https://"] { color: blue; }

14.Attribute Value Ends With Selector:
   ----------------------------------

Selects elements whose attribute values end with a specified string.

Example: [src$=".jpg"] { border: 1px solid #ccc; }

15.Attribute Value Contains Selector:
   ---------------------------------

Selects elements whose attribute values contain a specified string.

Example: [alt*="cat"] { border: 2px solid orange; }



5. Text Properties 
   ===============

CSS (Cascading Style Sheets) provides a wide range of text properties that allow you to control the appearance and layout of text within HTML elements. A list of common text properties in CSS.


1.color:
  -----
 
Sets the color of the text.
Example: color: red;

2.direction:
  ---------

Sets the text direction, such as ltr (left-to-right) or rtl (right-to-left).
Example: direction: rtl;

3.text-transform:
  --------------

Modifies the capitalization of text, e.g., uppercase or lowercase or capitalize.
Example: text-transform: uppercase;

4.text-shadow:
  -----------

It gives shadow to text.
 
text-shadow: x-axis y-axis blur color
text-shadow: 10px 0px 10px red

5.text-align:
  ----------

Aligns the text horizontally within its container.
Example: text-align: center;

6.text-decoration:
  ---------------

Controls decorations like underline, overline, and line-through.
Example: text-decoration: underline;

7.text-indent:
   -----------

Sets the indentation of the first line of text within an element.
Example: text-indent: 20px;


8.font-family:
  -----------

Specifies the font family for the text.
Example: font-family: Arial, sans-serif;

9.font-size:
   ---------

Sets the size of the text.
Example: font-size: 16px;

10.font-weight:
   -----------

Defines the thickness or boldness of the text.
Example: font-weight: bold;

11.font-style:
   ----------

Specifies the style of the text, such as italic.
Example: font-style: italic;


12.line-height:
   -----------

Sets the height of a line of text, controlling spacing between lines.
Example: line-height: 1.5;


13.letter-spacing:
  --------------

Adjusts the space between individual characters.
Example: letter-spacing: 2px;

14.word-spacing:
  ------------

Controls the spacing between words in a block of text.
Example: word-spacing: 4px;

These are some of the essential text properties in CSS. By using these properties, you can customize the appearance and layout of text on your web pages, making it an integral part of web design and typography.



6. Background Properties
   =====================


1.background-color:
  ---------------

<style>
  .example {
    background-color: #F0F0F0;
  }
</style>

<div class="example">
  This is a div with a colored background.
</div>

2.background-image:
  ----------------

<style>
  .example {
    background-image: url('image.jpg');
  }
</style>

<div class="example">
  This is a div with a background image.
</div>


3.background-repeat: ( repeat (default) | repeat-x | repeat-y | no-repeat )
  -----------------

=> Repeating horizontally and vertically 

.example-repeat {
    background-image: url('repeating-pattern.png');
    background-repeat: repeat;
}

=> Repeating horizontally only 

.example-repeat-x {
    background-image: url('horizontal-pattern.png');
    background-repeat: repeat-x;
}

=> Repeating vertically only 

.example-repeat-y {
    background-image: url('vertical-pattern.png');
    background-repeat: repeat-y;
}

=> No repetition 

.example-no-repeat {
    background-image: url('single-image.jpg');
    background-repeat: no-repeat;
}

ex:
--

<style>
  .example {
    background-image: url('image.jpg');
    background-repeat: no-repeat;
  }
</style>

<div class="example">
  This is a div with a non-repeating background image.
</div>


4.background-position:   left top | left center | left bottom | right top | right center |
  ------------------     right bottom | center top | center center | center bottom
  

<style>
  .example {
    background-image: url('image.jpg');
    background-position: center top;
  }
</style>

<div class="example">
  This is a div with a centered top-aligned background image.
</div>


5.background-size:
  ---------------

=> Original size (auto) 

.example-auto {
    background-image: url('large-image.jpg');
    background-size: auto;
}

=> Scale to cover the content area 

.example-cover {
    background-image: url('image.jpg');
    background-size: cover;
}

=> Scale to fit within the content area

.example-contain {
    background-image: url('image.jpg');
    background-size: contain;
}

=> Specific size in pixels 

.example-specific-size {
    background-image: url('image.jpg');
    background-size: 200px 150px;
}

=> Relative size with percentages 

.example-percent-size {
    background-image: url('image.jpg');
    background-size: 50% 75%;
}

Ex:

<style>
  .example {
    background-image: url('image.jpg');
    background-size: cover;
  }
</style>

<div class="example">
  This is a div with a background image that covers the entire element.
</div>

Note:
----

The 'cover' tells the browser to cover the whole area of an element. 
The 'contain' tells the browser to show the whole image without loosing image.


6.background-attachment: (scroll | fixed)
  ---------------------

=> Background image scrolls with content (default) 

.example-scroll {
    background-image: url('scrolling-background.jpg');
    background-attachment: scroll;
}

=> Background image remains fixed in place

.example-fixed {
    background-image: url('fixed-background.jpg');
    background-attachment: fixed;
}

Ex:
--

<style>
  .example {
    background-image: url('image.jpg');
    background-attachment: fixed;
  }
</style>

<div class="example">
  This is a div with a fixed background image.
</div>


These are just a few examples of how you can use CSS background properties to style and enhance the backgrounds of HTML elements. You can combine these properties and adjust their values to achieve the desired visual effects in your web pages.



7. Border properties
   =================

In CSS (Cascading Style Sheets), you can use various properties to control the appearance of borders around elements such as text, images, and containers. Here are some common border properties in CSS:

1)border-width:
--------------

This property sets the width of the border. You can specify the width in pixels, ems, rems, percentages, or other units. 

border-width: 2px;

2)border-color:
-------------- 
This property sets the color of the border. You can use color names, hexadecimal values, RGB values, or other color notations. 

border-color: #FF0000;


3)border-style:
-------------- 

This property sets the style of the border, and it can take values like "solid," "dashed," "dotted," "double," "none,". 

border-style: solid;


4)border-radius:
---------------
 
This property sets the radius of the corners of an element, creating rounded corners. You can specify different values for each corner or use a single value for all corners.

The border-radius property is actually a shorthand property for the 

border-top-left-radius, 
border-top-right-radius, 
border-bottom-right-radius 
border-bottom-left-radius 
 
border-radius: 10px;

5)border-image:
--------------
 
This property allows you to use an image as a border instead of a solid color. It's a more advanced property and requires defining an image to use as a border.

border-image: url(border-image.png) 27 27 27 27 round round;

      border-image-source: url('./102.PNG');
      border-image-slice: 30%;
      border-image-width: 20px;
      border-image-repeat: repeated, stretched(default).
      border-image-outset: 20px


border-image is a shorthand property that lets you use an image or CSS gradient as the border of an element.

The border-image property can be applied to any element, except internal table elements (e.g. tr, th, td) when border-collapse is set to collapse.

The border-image-outset property specifies the amount by which the border image area extends beyond the border box


border:
------ 

This is a shorthand property that combines border-width, border-style, and border-color into a single declaration.
 
border: (width) 1px (style)solid (color) #000;




8. Margin and Padding properties
   =============================

margin
------

The CSS margin property is used to give space around an element on a web page. It defines the area outside the element's border. Margins are used to create space and separation between elements.


1)margin-top: 10px;

2)margin-right: 20px;

3)margin-bottom: 15px;

4)margin-left: 25px;

5)margin: 10px 20px 15px 25px; (top, right, bottom, left) 

6)margin: 10px 20px   (Top and bottom have 10px margin, right and left have 20px margin)
 
7)margin: 10px 20px 15px   (Top has 10px margin, right and left have 20px margin, bottom has 15px margin) 
8)margin: 10px  (all sides)

9)margin: auto

You can set the margin property to auto to horizontally center the element within its container.
The element will then take up the specified width, and the remaining space will be split equally between the left and right margins.

Margin Collapse
---------------

Top and bottom margins of elements are sometimes collapsed into a single margin that is equal to the largest of the two margins.

This does not happen on left and right margins! Only top and bottom margins!


padding
-------

Padding is used to create space within an element, between the element's content and its border.


1)padding-top: 10px;

2)padding-right: 20px;

3)padding-bottom: 15px;

4)padding-left: 25px;

5)padding: 10px 20px 15px 25px; /* top, right, bottom, left */

6)padding: 10px 20px  

7)padding: 10px 20px 15px

8)padding: 10px (all sides)


margin vs padding
-----------------

In CSS, both margin and padding are properties used to control spacing, but they affect the layout of elements in different ways:

Margin:
------

-Margin controls space outside an element, between the element's border and neighboring elements.
-Margins create separation between elements.
-Margin values can be positive (adding space) or negative (reducing space).
-Margin do not have a background color or visible area, they only affect the spacing between elements.
-Margins can "collapse" under certain conditions, meaning that if two adjacent elements have margins, the larger of the two margins is used, and they don't stack.

Ex:

div {
  margin: 10px;
}

In this example, a div element will have a 10-pixel margin around it, creating space between it and neighboring elements.

Margin collapse
---------------

The concept of "margin collapsing" in CSS refers to how margins between adjacent elements are computed when they are touching or close to each other. When two or more vertical margins meet or overlap under specific conditions, they don't simply add up or stack on top of each other as you might expect. Instead, they collapse, and the larger of the two margins is used to create the space between the elements. Here's a more detailed explanation:

=> Margins Collapsing Conditions:

Margins can collapse in the following situations:

When two or more block-level elements are vertically adjacent, meaning they are stacked on top of each other in the document flow.
When there is no padding, border, or inline content separating the elements.
When the margins are of the same type (e.g., both are top margins or both are bottom margins).

=> Result of Margin Collapsing:

When margins collapse, the larger of the margins is used, and the smaller margin effectively disappears in terms of creating spacing.
This means that if one element has a margin of 10px, and the adjacent element has a margin of 20px, the effective spacing between them will be 20px, not 30px.

=> Preventing Margin Collapsing:

You can prevent margin collapsing by introducing a non-collapsible element between the two elements. For example, adding padding, a border, or inline content between the elements will stop margin collapsing.

Example of margin collapsing:


p {
  margin: 10px 0;
}

div {
  margin: 20px 0;
}

In this example, if a <p> element and a <div> element are placed next to each other, the effective vertical space between them will be 20px, not 30px, because the larger of the two margins (20px) takes precedence



Padding:
-------

-Padding controls the space inside an element, between the element's content and its border.
-Padding is used to create space within an element, affecting the content's position within the   element's boundaries.
-Padding values can be positive (adding space) and are never negative.
-Padding has a background color and visible area. It extends the background of the element.

EX:

div {
  padding: 10px;
}

In this example, a div element will have a 10-pixel padding inside it, pushing the content away from the border.


Note: Inline elements vertical padding
====

In CSS, inline elements, by default, do not respect vertical padding in the same way that block-level elements do. Vertical padding on inline elements will not push away adjacent inline elements. Instead, it may cause overlapping or wrapping of the content within the inline element.

When you apply vertical padding to an inline element, such as <span> or a text within a paragraph, it increases the height of the element but doesn't create space around it like it does with block-level elements. This means that if you have multiple inline elements with padding, they might overlap or wrap to the next line depending on the available space within their container.

If you want to create space around inline elements, you can use margin instead of padding, or you can change the display property of the elements to inline-block or inline-flex, which will make them behave more like block-level elements, respecting vertical padding and margin.

<p>
  <span class="inline">This is some text.</span>
  <span class="inline">This is some text with padding.</span>
</p>
CSS:


span.inline {
  padding: 10px;
  margin: 10px;
}

In this example, the padding will increase the height of each inline element, but the adjacent inline elements won't be pushed away. They may overlap or wrap to the next line depending on the available width of the containing element. If you want to create space between these inline elements, you would need to use margin or consider changing the display property to make them behave like block-level elements.



9. Width and height properties
   ===========================

Note: width and height in % => depends on  parent's width and height.
====

 - width = Width will be always fixed irrespective of screen size.

 - min-width = min-width is fixed for given size and beyong min-width it depends on screen size.
  
 - max-width = max-width is fixed for given size and below max-width it depends on screen size.

 - height = Height is fixed it will not be depend on screen size.

 - min-height = min-height is fixed for given size and beyond min-height depends on screen size.

 - max-height = max-height is fixed for given size and below max-height it depends on screen size.


Ex:

In CSS, height, min-height, and max-height are properties used to control the height of an element, such as a container or a block-level element. They serve different purposes and have distinct effects:

height:
------

The height property sets the exact height of an element to a specific value in pixels, ems, rems, percentages, or other length units. This value is often fixed and doesn't change unless you explicitly modify it.
If the content inside the element exceeds the specified height, it may overflow and be hidden or affect the layout of surrounding elements unless you use additional CSS properties to manage overflow, like overflow: hidden or overflow: scroll.

.element {
  height: 200px;
}

min-height:
----------

The min-height property sets the minimum height that an element should have. It ensures that the element is at least as tall as the specified value, but it can expand beyond that height if needed to accommodate content or other factors.
If the content within the element is taller than the specified min-height, the element's height will adjust to fit the content.

.element {
  min-height: 100px;
}

max-height:
----------

The max-height property sets the maximum height that an element can have. It restricts the height to not exceed the specified value. If the content or other factors would cause the element to be taller than the max-height, it will be limited to that height, and scrollbars may appear to allow users to access the overflow content.

.element {
  max-height: 300px;
}

You can use these properties individually or in combination to control the height of elements in your web page layout. They are particularly useful when dealing with responsive web design, ensuring that elements adapt to various screen sizes and content while maintaining a defined range of height.




10. Display Property
    ================

In CSS, the display property is used to control how an HTML element is displayed in the web browser. It defines the type of box an element generates, which in turn affects its layout and rendering on the web page. There are various display property values that determine the element's behavior. Here are some common display property values:

1.block:
-------

The element is displayed as a block-level element.
It takes up the full width available in its parent container and starts on a new line.
Examples of block-level elements include <div>, <p>, and <h1>.

2.inline:
--------

The element is displayed as an inline-level element.
It takes up only as much width as necessary and does not start on a new line.
Examples of inline-level elements include <span>, <a>, and <strong>.

3.inline-block:
--------------

Combines characteristics of both inline and block.
The element is inline, but it can have its own width and height, as well as margin and padding.
Elements with this display type can be positioned inline, but they can have block-level styling.

Note:
----

=> inline The element doesn’t start on a new line and only occupy just the width it requires. You can’t set the width or height.

=> inline-block It’s formatted just like the inline element, where it doesn’t start on a new line. BUT, you can set width and height values.

=> block element will start on a new line and occupy the full width available. And you can set width and height values.


4.none:
------

The element is not displayed at all, effectively making it invisible.
It doesn't occupy any space in the layout.

5.table:
-------

The element is displayed as a table element.
It can have child elements with table-row, table-cell, and other table-related display values.

6.flex:
------

The element becomes a flex container, and its children become flex items.
It is used to create flexible and responsive layouts, allowing elements to adjust their sizes based on available space.

7.grid:
------

The element becomes a grid container, and its children become grid items.
It is used to create grid-based layouts, providing fine control over the arrangement of items.


display: none vs visibility: hidden vs opacity: 0
=================================================

In CSS, display: none, visibility: hidden, and opacity: 0 are three different ways to hide elements on a web page, and they have distinct behaviors and use cases.

display: none
-------------

When you apply display: none to an element, the element is completely removed from the layout of the page. It takes up no space, and the document flows as if the element does not exist.
Child elements of the hidden element are also hidden, and they do not affect the layout.
Events and interactions (e.g., clicking, hovering) cannot target hidden elements.
Good for situations where you want to completely remove an element from view and layout.

element {
  display: none;
}

visibility: hidden
------------------

When you apply visibility: hidden to an element, the element is still part of the layout, but it is not visible. It still takes up space on the page, as if it were still visible. Child elements of the hidden element are also hidden, but they still affect the layout. Events and interactions can still target hidden elements. Useful when you want to hide an element but maintain its space in the layout.

element {
  visibility: hidden;
}

opacity: 0
----------

When you set opacity: 0, the element becomes fully transparent, but it still occupies the same space in the layout.
Child elements of the transparent element remain visible and affect the layout.
Events and interactions can target the transparent elements.
Useful when you want to hide an element while maintaining its layout position and possibly animate the element's visibility.

element {
  opacity: 0;
}

In summary, the choice of which property to use (display, visibility, or opacity) depends on your specific requirements. If you want to completely remove the element and its space from the layout, display: none is suitable. If you want to hide the element but maintain its space in the layout, visibility: hidden is appropriate. If you want to hide the element but keep its space and potentially use transitions or animations, opacity: 0 is a good choice.



11) Block level vs Inline elements default behaviour
    ================================================

In HTML, content placement within block-level and inline elements follows specific rules that determine how elements are displayed and how they interact with the surrounding content.

Block-Level Elements:
--------------------

Block-level elements create distinct blocks or containers within the layout. They naturally start on a new line and take up the full available width of their parent container. Content within block-level elements is displayed in a "block" format.

Here's how content is typically placed within block-level elements:
-------------------------------------------------------------------

On New Lines: 
------------
Block-level elements start on a new line, and subsequent block-level elements are displayed below the previous one. This means each block-level element creates a new "block" in the layout.

Full Width: 
----------
By default, block-level elements span the full width of their parent container, unless specified otherwise using CSS properties like width.

Vertical Stacking:
----------------- 
Block-level elements stack vertically, creating a clear separation between different sections or blocks of content. Common examples of block-level elements include paragraphs (<p>), headings (<h1>, <h2>, etc.), lists (<ul>, <ol>), and div containers (<div>).


<div>This is a block-level container.</div>
<div>Another block-level container.</div>

-Block-level elements naturally create distinct "blocks" within the layout. Content placed within   block-level elements is organized into separate, vertically stacked sections.
-Block-level elements extend the full width of their parent container by default. This means that   they create new lines for each block-level element, and each block-level element takes up the     entire width available.
-Block-level elements are ideal for structuring and organizing the content into different sections  or divisions of a web page.


Inline Elements:
---------------

Inline elements, flow within the content of their parent block-level elements. They don't create new lines or block-level structures themselves.

Here's how content is typically placed within inline elements:
-------------------------------------------------------------

Within Text Flow:
---------------- 
Inline elements flow within the text content of their parent block-level element. They do not create new lines, and their width adjusts to fit the content they contain.

No Line Breaks:
-------------- 
Inline elements do not introduce line breaks, and they wrap to the next line only if there is not enough horizontal space within their parent block-level element.

Horizontal Flow:
--------------- 
Content within inline elements flows from left to right (in left-to-right writing systems) or from right to left (in right-to-left writing systems).


<p>This is a <span>inline element</span> within a paragraph.</p>
In this example, the <span> element is an inline element and flows within the text of the paragraph. It doesn't introduce new lines or separate blocks of content.

-Inline elements are designed to flow within the content of a block-level element. They do not create distinct blocks or new lines by default.
-Inline elements are often used for applying formatting and styling to specific parts of text  or for embedding elements within a paragraph of text.
-By default, inline elements do not create a new block formatting context and flow within the content of their parent block-level element. They only take up as much horizontal space as necessary to contain their content.
-Inline elements do not accept width or height properties. The margin-top and margin-bottom properties do not create vertical spacing between inline elements in the same way they do for block-level elements.


To control the placement of content within both block-level and inline elements, you can use various HTML and CSS properties, such as display, position, and others, to modify their default behaviors and achieve the desired layout and structure in your web pages.


Content vs width vs height vs margin vs padding vs border
=========================================================

The behavior of content, width, height, margin, padding, and border for inline and block-level elements in HTML and CSS differs due to their default display characteristics.

Content:
-------
Block-Level Elements: 

Block-level elements create separate blocks or containers within the layout. They naturally start on new lines and contain their content within distinct blocks. Block-level elements can hold other elements and text content.

Inline Elements: 

Inline elements flow within the text content of their parent block-level element. They do not create new lines or separate blocks and are typically used for styling portions of text or inline content.

Width and Height:
----------------
Block-Level Elements: 

Block-level elements, by default, extend across the full width of their parent container. You can explicitly set their width using CSS to control the element's horizontal size, and you can set their height to control their vertical size.

Inline Elements: 

Inline elements take up only as much horizontal space as necessary to contain their content. Applying a width or height property to inline elements doesn't typically have the same effect as it does for block-level elements. Inline elements are usually self-sizing based on their content.

Margin:
------
Block-Level Elements: 

Block-level elements use the margin property to create spacing around them. Margins apply both vertically and horizontally, creating space outside the element's border. You can set margins for all four sides individually.

Inline Elements:
 
Inline elements can have horizontal margins (left and right), but their vertical margins (top and bottom) may not create the same spacing effects as they do for block-level elements. Margins often affect the horizontal layout and the positioning of the inline elements in relation to surrounding content.

Padding:
-------
Block-Level Elements: 

Block-level elements use the padding property to create spacing within the element, affecting the space between the element's content and its border. Padding properties apply both vertically and horizontally and can be set for all four sides individually.

Inline Elements: 

Inline elements can have horizontal padding (left and right), but vertical padding (top and bottom) may not have the same impact. Padding for inline elements often affects the horizontal spacing and the positioning of the content within the element.

Border:
------
Block-Level Elements: 

Block-level elements can have a border defined using the border property. The border surrounds the entire block and is often used for creating visual boundaries around content.

Inline Elements: 

Inline elements can also have borders, but the effect might differ. Borders may not consistently create a clear block-like boundary around inline elements due to their inline flow. The border can be applied to individual sides (e.g., border-left, border-right) to control how it appears in relation to the inline content.

In summary, block-level elements are typically used to create distinct blocks of content with more control over their width, height, margins, padding, and borders. Inline elements, on the other hand, are used for styling inline content within a block-level element and may not have the same level of control over these properties due to their inline flow. However, you can modify the default behavior of elements using CSS to achieve the desired layout and styling.


Inline elements 
===============

Horizontal behaviour:
--------------------
width: no effect
padding: work correctly
border: work corectly
margin: work correctly

Vertical behaviour:
------------------
height: no effect
margin: no effect
padding: go into block level element
border: go into block level element




12. Box model
    =========

The CSS box model is a container that contains multiple properties including borders, margins, padding, and the content itself. It is used to create the design and layout of web pages. It can be used as a toolkit for customizing the layout of different elements. The web browser renders every element as a rectangular box according to the CSS box model. 

The CSS box-model and box-sizing are related concepts, but they serve different purposes when it comes to controlling how the dimensions of elements are calculated. Let me explain the difference between them:

The CSS box model, defines how an element's dimensions are calculated, taking into account the content, padding, border, and margin.
By default, when you set the width and height properties of an element, you are specifying the dimensions of the content area. The padding, border, and margin are added to these dimensions.

.box {

  width: 200px;
  height: 100px;
  padding: 20px;
  border: 2px solid #000;
  margin: 10px;
}

The total space the .box element occupies on the page is calculated by summing the content width, padding, border, and margin, as described in the previous answer.

Box-Sizing Property:
-------------------

The box-sizing property allows you to control how an element's dimensions are calculated, specifically how width and height are interpreted.

The box-sizing property has two possible values:

content-box (default): 
---------------------
This is the default behavior, where width and height represent the dimensions of the content area. Padding, border, and margin are added to these dimensions.

border-box:
---------- 
With this value, width and height include the content area, padding, and border. The margin is still outside of these dimensions. If you set an element's box-sizing property to border-box, the specified width and height values will include the padding and border. This can be helpful for creating more predictable layouts, as you can work with the total space an element occupies.

Here's an example of how to use the box-sizing property:

.box {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 2px solid #000;
  margin: 10px;
  box-sizing: border-box; /* Include padding and border in width and height */
}

In this case, the specified width and height values will include the padding and border, making it easier to control the overall dimensions of the element while ensuring that the content area remains a consistent size.

In summary, the CSS box-model defines the standard model for calculating element dimensions, and the box-sizing property allows you to change how width and height are interpreted, either as content dimensions or including padding and border.


13) Positions:
    =========

In CSS position property is used to position HTML element in HTML document.

While using position property, we take help of left, right, top, bottom and z-index properties to position HTML element. 


   1) static :
      ------
      It is default position for all html elements we can not move element's position using top, left, right, bottom.

   2) relative : 
      --------
      Element will be displayed as per normal flow of document.
      It considers its own position as a reference point to move.

   3) absolute :
      --------
      Element will not be displayed as per normal flow of document.
      It considers its positioned relative parent element as a reference point to move.
      If no positioned parent then it takes top most parent(html/viewport) as reference point.     
      
   4) fixed :
      -----
      Element will not be displayed as per normal flow of document.
      It always considers html element(viewport) as a reference point to move, 
      So it stays (fixed) in the same position even when the page is scrolled.

   5) sticky :
      ------
      It is used to position and stick an HTML element to top edge of viewport.
      Sticky positioning is a hybrid between relative and fixed positioning.
      It will work initially as a relative (it will move certain extent) after that it will be fixed.


z-index: 
========

The z-index property is typically used with positioned elements, such as relative,absolute,fixed. It does not have any effect on non-positioned (static) elements.

- Controls the stacking order of elements. 
- Elements with higher z-index values appear in front of elements with lower values.
- If multiple elements have the same z-index, their stacking order is determined by their order in the HTML document. The element that appears later in the document will be on top.
- The z-index property only works on elements with a position value other than static. So, you need to set element's position property to relative, absolute,fixed for z-index to have effect.
- Negative values for z-index are allowed, and elements with negative z-index values will be placed  behind elements with positive values.



15. Responsive Design
    =================

Media queries
-------------

-Media queries are essential for creating responsive web designs that adapt to various devices and screen sizes, providing a better user experience.

-Media query is a technic of applying different styles to an element based on certain condition.
 
-They are commonly used to provide different styles for different devices by their features like type, width, height, orientaion.

Syntax:

1)@media
  ------
 
Media queries use the @media rule and have a specific syntax. 


@media screen and (max-width: 600px) {

  /* CSS rules for screens with a width of 600px or less */
}

In this example, the media query targets screens with a width of 600 pixels or less.

2) Media Types:
   ----------- 

You can specify different media types (screen, print, speech) to apply styles in different contexts. The most commonly used media type is screen.

-screen
-print
-speech

3) Media Features:
   --------------
 
Media features like max-width, min-width, min-height, max-height, orientation,and many others are used to specify the conditions under which the CSS rules should be applied.

-min-width
-max-width
-min-height
-max-height
-orientation (landscape, portrait)

Here are some common examples of media queries:

Max-width: 
---------

To apply styles when the viewport width is at most a certain size.

@media screen and (max-width: 768px) {

  /* CSS rules for screens with a width of 768px or less */
}

Min-width: 
---------

To apply styles when the viewport width is at least a certain size.


@media screen and (min-width: 1024px) {

  /* CSS rules for screens with a width of 1024px or more */
}

Orientation: 
-----------

To apply styles based on the device's orientation (portrait or landscape).


@media screen and (orientation: landscape) {

  /* CSS rules for landscape orientation */
}

4) Operators (Combining Conditions) 
   --------------------------------

You can combine multiple conditions using and, or, not, only to create more complex media queries.


@media screen and (min-width: 768px) and (max-width: 1024px) {

  /* CSS rules for screens between 768px and 1024px wide */
}

Media queries are essential for creating responsive web designs that adapt to various devices and screen sizes, providing a better user experience.